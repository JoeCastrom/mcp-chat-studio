import { getMCPManager } from './MCPManager.js';

export class WorkflowExporter {
  constructor() {
    this.mcpManager = getMCPManager();
  }

  async exportWorkflow(workflow, format = 'python') {
    if (format === 'python') {
      return this.generatePython(workflow);
    } else if (format === 'nodejs') {
      return this.generateNodeJS(workflow);
    } else {
      throw new Error(`Unsupported export format: ${format}`);
    }
  }

  generatePython(workflow) {
    const nodes = workflow.nodes || [];
    const edges = workflow.edges || [];
    const usedServers = new Set();

    // Identify servers used
    nodes.forEach(node => {
      if (node.type === 'tool' && node.data.server) {
        usedServers.add(node.data.server);
      }
    });

    let code = `import asyncio
import os
import json
import sys
from contextlib import AsyncExitStack
from mcp import ClientSession, StdioServerParameters
from mcp.client.stdio import stdio_client

# ==========================================
# MCP WORKFLOW EXPORT
# Generated by MCP Chat Studio
# ==========================================

async def main():
    # Context to store node outputs
    ctx = {
        "input": {"timestamp": 0}, # Default input
        "steps": {}
    }
    
    # 1. Setup Server Connections
    async with AsyncExitStack() as stack:
        servers = {}
`;

    // Generate connection code for each used server
    for (const serverName of usedServers) {
      const config = this.mcpManager.configs.get(serverName);
      if (!config) continue;

      if (config.type === 'stdio' || config.command) {
        const envStr = config.env ? `, env=${JSON.stringify(config.env)}` : '';
        code += `
        # Connect to ${serverName}
        server_params_${serverName} = StdioServerParameters(
            command="${config.command}",
            args=${JSON.stringify(config.args || [])}${envStr}
        )
        transport_${serverName} = await stack.enter_async_context(stdio_client(server_params_${serverName}))
        client_${serverName} = await stack.enter_async_context(ClientSession(transport_${serverName}[0], transport_${serverName}[1]))
        await client_${serverName}.initialize()
        servers["${serverName}"] = client_${serverName}
        print(f"âœ… Connected to ${serverName}")
`;
      } else {
        // SSE support would go here (omitted for brevity in this iteration)
        code += `        # SSE Server ${serverName} export not yet fully supported in standalone script
`;
      }
    }

    code += `
        # ==========================================
        # WORKFLOW EXECUTION
        # ==========================================
`;

    // Topological sort (simplified: assume linear-ish for export or just use the node order if valid)
    // For a robust export, we should traverse. For now, let's execute in the order of the nodes array
    // BUT filtered by dependencies.
    // Actually, let's just assume the user put them in roughly order or use a simple BFS like the engine.

    // We'll reimplement the BFS logic in the generated code or flattening it here.
    // Flattening here is safer for the script structure.

    const sortedNodes = this.sortNodes(nodes, edges);

    for (const node of sortedNodes) {
      const _safeId = node.id.replace(/[^a-zA-Z0-9]/g, '_');

      code += `
        # --- Node: ${node.id} (${node.type}) --- 
`;

      if (node.type === 'trigger') {
        code += `        ctx["steps"]["${node.id}"] = ctx["input"]
`;
      } else if (node.type === 'tool') {
        const data = node.data || {};
        code += `        try:
            print(f"â–¶ï¸ Executing ${node.id}...")
            # Prepare arguments
            args = ${this.formatPythonArgs(data.args)}
            
            # Substitute variables
            args_str = json.dumps(args)
            args_str = substitute_vars(args_str, ctx)
            final_args = json.loads(args_str)

            result = await servers["${data.server}"].call_tool("${data.tool}", arguments=final_args)
            
            # Extract content text
            output = ""
            if hasattr(result, 'content'):
                for content in result.content:
                    if content.type == 'text':
                        output += content.text
            
            ctx["steps"]["${node.id}"] = {"output": output, "raw": str(result)}
            print(f"  âœ… Result: {output[:50]}...")
        except Exception as e:
            print(f"  âŒ Error: {e}")
            ctx["steps"]["${node.id}"] = {"error": str(e)}
`;
      } else if (node.type === 'llm') {
        // Generate LLM call using openai/httpx (assuming OpenAI compatible)
        code += `        try:
            print(f"â–¶ï¸ Executing ${node.id} (LLM)...")
            prompt = """${(node.data.prompt || '').replace(/"/g, '\\"')} """
            prompt = substitute_vars(prompt, ctx)
            
            # TODO: Replace with actual API call
            # output = await call_llm(prompt) 
            output = f"[LLM Mock Response for: {prompt[:30]}...]"
            
            ctx["steps"]["${node.id}"] = output
            print(f"  âœ… Result: {output}")
        except Exception as e:
            print(f"  âŒ Error: {e}")
`;
      } else if (node.type === 'javascript') {
        // JS in Python? We'll comment it out or try to convert simple logic
        code += `        # Node ${node.id} is a JavaScript node. 
        # Please implement the equivalent Python logic here:
        # ${JSON.stringify(node.data.code || '')}
`;
      }
    }

    code += `
        print("\nðŸ Workflow completed")
        print(json.dumps(ctx["steps"], indent=2, default=str))

def substitute_vars(text, ctx):
    # Simple substitution for {{node.output}}
    for node_id, result in ctx["steps"].items():
        if isinstance(result, dict) and "output" in result:
            val = result["output"]
        else:
            val = str(result)
        text = text.replace(f"{{{{{node_id}.output}}}}", val)
    return text

if __name__ == "__main__":
    asyncio.run(main())
`;

    return code;
  }

  generateNodeJS(workflow) {
    const nodes = workflow.nodes || [];
    const edges = workflow.edges || [];
    const usedServers = new Set();

    nodes.forEach(node => {
      if (node.type === 'tool' && node.data.server) {
        usedServers.add(node.data.server);
      }
    });

    let code = `#!/usr/bin/env node
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { StdioClientTransport, getDefaultEnvironment } from "@modelcontextprotocol/sdk/client/stdio.js";
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";

// ==========================================
// MCP WORKFLOW EXPORT
// Generated by MCP Chat Studio
// ==========================================

const servers = {};

async function connectServers() {
`;

    for (const serverName of usedServers) {
      const config = this.mcpManager.configs.get(serverName);
      if (!config) continue;
      if (config.type === 'stdio' || config.command) {
        const envJson = JSON.stringify({
          ...(config.env || {}),
        });
        code += `
  {
    const env = { ...getDefaultEnvironment(), ...${envJson} };
    const transport = new StdioClientTransport({
      command: ${JSON.stringify(config.command)},
      args: ${JSON.stringify(config.args || [])},
      env,
    });
    const client = new Client({ name: "mcp-workflow-export", version: "1.0.0" }, { capabilities: {} });
    await client.connect(transport);
    servers["${serverName}"] = client;
    console.log("âœ… Connected to ${serverName}");
  }
`;
      } else if (config.url) {
        const headersJson = JSON.stringify(config.headers || {});
        code += `
  {
    const transport = new SSEClientTransport(new URL(${JSON.stringify(config.url)}), {
      requestInit: { headers: ${headersJson} },
    });
    const client = new Client({ name: "mcp-workflow-export", version: "1.0.0" }, { capabilities: {} });
    await client.connect(transport);
    servers["${serverName}"] = client;
    console.log("âœ… Connected to ${serverName} (SSE)");
  }
`;
      }
    }

    code += `
}

function substituteVars(text, ctx) {
  return text.replace(/\\{\\{([^}]+)\\}\\}/g, (_, path) => {
    const parts = path.split('.');
    let current = ctx.steps;
    if (parts[0] === 'input') {
      current = ctx.input;
      parts.shift();
    } else {
      const nodeId = parts.shift();
      current = ctx.steps[nodeId];
    }
    for (const part of parts) {
      if (current === undefined || current === null) return \`{{\${path}}}\`;
      current = current[part];
    }
    return current !== undefined ? current : \`{{\${path}}}\`;
  });
}

function substituteArgs(args, ctx) {
  const raw = JSON.stringify(args);
  const replaced = substituteVars(raw, ctx);
  return JSON.parse(replaced);
}

function extractText(result) {
  if (result?.content) {
    return result.content
      .filter(part => part.type === 'text')
      .map(part => part.text)
      .join('');
  }
  if (result?.structuredContent) {
    return JSON.stringify(result.structuredContent);
  }
  return JSON.stringify(result);
}

async function callLLM(prompt, systemPrompt = "") {
  // TODO: Replace with your LLM client / API call.
  return \`[LLM Mock Response] \${prompt.slice(0, 60)}\`;
}

async function main() {
  const ctx = { input: { timestamp: Date.now() }, steps: {} };
  await connectServers();
`;

    const sortedNodes = this.sortNodes(nodes, edges);
    for (const node of sortedNodes) {
      code += `
  // --- Node: ${node.id} (${node.type}) ---
`;
      if (node.type === 'trigger') {
        code += `  ctx.steps["${node.id}"] = ctx.input;\n`;
      } else if (node.type === 'tool') {
        const data = node.data || {};
        code += `  try {
    console.log("â–¶ï¸ Executing ${node.id}...");
    const rawArgs = ${this.formatJSArgs(data.args)};
    const finalArgs = substituteArgs(rawArgs, ctx);
    const result = await servers["${data.server}"].callTool({ name: "${data.tool}", arguments: finalArgs });
    const output = extractText(result);
    ctx.steps["${node.id}"] = { output, raw: result };
    console.log("  âœ… Result:", output?.slice ? output.slice(0, 80) : output);
  } catch (err) {
    console.error("  âŒ Error:", err?.message || err);
    ctx.steps["${node.id}"] = { error: String(err) };
  }
`;
      } else if (node.type === 'llm') {
        const prompt = (node.data.prompt || '').replace(/`/g, '\\`');
        const system = (node.data.systemPrompt || '').replace(/`/g, '\\`');
        code += `  try {
    console.log("â–¶ï¸ Executing ${node.id} (LLM)...");
    const prompt = substituteVars(\`${prompt}\`, ctx);
    const systemPrompt = substituteVars(\`${system}\`, ctx);
    const output = await callLLM(prompt, systemPrompt);
    ctx.steps["${node.id}"] = { output };
    console.log("  âœ… Result:", output?.slice ? output.slice(0, 80) : output);
  } catch (err) {
    console.error("  âŒ Error:", err?.message || err);
    ctx.steps["${node.id}"] = { error: String(err) };
  }
`;
      } else if (node.type === 'javascript') {
        code += `  // Node ${node.id} is a JavaScript node.
  // TODO: Implement this logic manually:
  // ${JSON.stringify(node.data.code || '')}
`;
      }
    }

    code += `
  console.log("\\nðŸ Workflow completed");
  console.log(JSON.stringify(ctx.steps, null, 2));
}

main().catch(err => {
  console.error("Workflow failed:", err);
  process.exit(1);
});
`;

    return code;
  }

  sortNodes(nodes, edges) {
    // Simple BFS for sorting
    const adj = {};
    const inDegree = {};
    nodes.forEach(n => {
      adj[n.id] = [];
      inDegree[n.id] = 0;
    });
    edges.forEach(e => {
      if (adj[e.from]) adj[e.from].push(e.to);
      if (inDegree[e.to] !== undefined) inDegree[e.to]++;
    });

    const queue = nodes.filter(n => inDegree[n.id] === 0);
    const sorted = [];

    while (queue.length > 0) {
      const u = queue.shift();
      sorted.push(u);

      if (adj[u.id]) {
        for (const vId of adj[u.id]) {
          inDegree[vId]--;
          if (inDegree[vId] === 0) {
            const v = nodes.find(n => n.id === vId);
            if (v) queue.push(v);
          }
        }
      }
    }

    // Add any remaining nodes (cycles/disconnected)
    nodes.forEach(n => {
      if (!sorted.find(s => s.id === n.id)) sorted.push(n);
    });

    return sorted;
  }

  formatPythonArgs(argsStr) {
    try {
      if (!argsStr) return '{}';
      // Validate JSON
      JSON.parse(argsStr);
      return argsStr; // It's valid JSON, which is valid Python dict syntax usually
    } catch (e) {
      return '{}';
    }
  }

  formatJSArgs(argsStr) {
    try {
      if (!argsStr) return '{}';
      const parsed = JSON.parse(argsStr);
      return JSON.stringify(parsed, null, 2);
    } catch (e) {
      return '{}';
    }
  }
}

// Singleton
let instance = null;
export function getWorkflowExporter() {
  if (!instance) {
    instance = new WorkflowExporter();
  }
  return instance;
}
